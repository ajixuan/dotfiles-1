""" General
set nocompatible

""" Plugins
" Let vimballs extract themselves in bundle/out/
" so we can play with them ourselves.
let g:vimball_home=$HOME."/.vim/bundle/out"

" Log Vim commands
if has('cmdlog')
    set cmdlogdir=~/.vimlogs/
    " set cmdloginsert
end

" Haskell mode
"let g:haddock_browser="nothing"

au BufEnter *.hs compiler ghcx

" Ack.vim
"let g:ackprg="ack-grep -H --nocolor --nogroup --column"
"let g:ackprg="ack -H --nocolor --nogroup --column"
let g:ackprg="ag --nocolor --nogroup --column"
nmap <unique> <Leader>a :Ack<SPACE>

" Pathogen, activate!
call pathogen#infect()

""" Whitespace, indention, etc.
set sw=4 sts=4 et
set ts=8
set nosmartindent
set cin noai
set tw=60 cc=60
set nojoinspaces

" g:StragerGetCStyleComments returns a list of 'comments parts. Use this
" function in ftplugin-s.
function g:StragerGetCStyleComments()
  return ['sO:*\ -', 'mO:*\ \ ', 'exO:*/', 's1:/*', 'mb:*', 'ex:*/', '://']
endfunction

" Copyright Saleem Abdulrasool <compnerd@compnerd.org>
command! GNUFormat :setlocal
    \ cinoptions=>2s,n-1s,{s,^-1s,:1s,=1s,g0,h1s,t0,+1s,(0,u0,w1,m1
    \ noexpandtab
    \ shiftwidth=2
    \ softtabstop=2
    \ tabstop=8

""" Text manipulation
set bs=indent,eol,start
set completeopt=menu,preview
set noesckeys

" Synchronize default Vim register and system clipboard.
set clipboard=unnamed

""" Text alignment
""" http://vim.wikia.com/wiki/Regex-based_text_alignment
command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')
function! AlignSection(regex) range
  let extra = 1
  let sep = empty(a:regex) ? '=' : a:regex
  let maxpos = 0
  let section = getline(a:firstline, a:lastline)
  for line in section
    let pos = match(line, ' *'.sep)
    if maxpos < pos
      let maxpos = pos
    endif
  endfor
  call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
  call setline(a:firstline, section)
endfunction

function! AlignLine(line, sep, maxpos, extra)
  let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
  if empty(m)
    return a:line
  endif
  let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
  return m[1] . spaces . m[2]
endfunction

" Make Y consistent with D (i.e. D : d$ :: Y : y$)
nmap <unique> Y y$

""" Navigation
set foldmethod=marker
if v:version >= 703
    set relativenumber
endif
set numberwidth=3

" Sane searching
set hlsearch
set incsearch
set smartcase ignorecase
nmap <unique> <Leader>l :nohlsearch<CR>

" Save searches
set viminfo+=/200

" Use space to find space
" (Note the space after f, F)
" Kinda broken right now...
nmap <unique> <Space> ef<Space>

" Use tab for %
nnoremap <unique> <tab> %
vnoremap <unique> <tab> %

" Navigate jump list with \j, \k
nnoremap <unique> <Leader>j <C-I>
nnoremap <unique> <Leader>k <C-O>

""" Window and tab management
" Windows
nmap <unique> th <C-W>h
nmap <unique> tl <C-W>l
nmap <unique> tj <C-W>j
nmap <unique> tk <C-W>k
nmap <unique> ts :split<SPACE>
nmap <unique> tv :vsplit<SPACE>
nmap <unique> tc <C-W>c
set splitbelow splitright

" Tabs
nmap <unique> Th :tabp<CR>
nmap <unique> Tl :tabn<CR>
nmap <unique> Te :tabe<SPACE>
nmap <unique> Tn :tabe .<CR>
nmap <unique> Tc :tabc<CR>

nmap <unique> TH :tabp<CR>
nmap <unique> TL :tabn<CR>
nmap <unique> TE :tabe<SPACE>
nmap <unique> TN :tabe .<CR>
nmap <unique> TC :tabc<CR>

nmap <unique> tH :tabp<CR>
nmap <unique> tL :tabn<CR>
nmap <unique> tE :tabe<SPACE>
nmap <unique> tN :tabe .<CR>
nmap <unique> tC :tabc<CR>

nmap <unique> te :tabe<SPACE>

""" File management
set autowrite 

""" netrw
let g:netrw_banner = 0
let g:netrw_use_errorwindow = 0

" Don't hide any files from completion.
set wildignore=

" Put swap files in ~/.vim/swap/.  Note the double /:
"
" > - For Unix and Win32, if a directory ends in two path separators "//"
" >  or "\\", the swap file name will be built from the complete path to
" >  the file with all path separators substituted to percent '%' signs.
" >  This will ensure file name uniqueness in the preserve directory.
set directory=~/.vim/swap//,.

" fzf
nmap <unique> ' :Buffers<CR>
nmap <unique> <C-P> :Files<CR>

""" Display
set nowrap
set ruler
set laststatus=2
set listchars+=precedes:<,extends:>
set sidescroll=5
set scrolloff=5
set shortmess=a     " Abbreviate status line
set shortmess+=tToO " Other crap

" filename [Help][-][RO]
set statusline=\ \ \ %<%f\ %h%m%r
" Line, col
set statusline+=%=%(%l,%c%V%)

""" Command line
set wildmenu
set wildmode=longest,full

" Save history
set history=200
set viminfo+=:200

""" Syntax hilighting
syntax on
filetype on
filetype indent on
filetype plugin on

au BufNewFile *.as set filetype=javascript
au BufRead *.as set filetype=javascript

" Prefer 8-color over 256-color. The colour scheme is tuned
" for 8-color with iTerm.
if &term =~ "xterm-256color"
  set term=xterm
endif

set background=dark
let g:solarized_termtrans=1
colorscheme solarized

" Make the vertical split column blend with the line number
" column.
highlight LineNr cterm=bold ctermbg=0 ctermfg=2
if v:version >= 800
  highlight! link CursorLineNr LineNr
endif
highlight VertSplit cterm=bold ctermbg=0 ctermfg=2
set fillchars+=vert:\ 

" HACK(strager): If the following are all true, Vim will
" force the 'fillchars stl item to '^':
"
" * The StatusLine and StatusLine highlight attributes are
"   equivalent
" * The stl and stlnc items are equal
" * The window being drawn is the current window
"
" We don't want this, so choose slightly different colours
" so we hopefully don't notice any difference.
highlight StatusLine cterm=bold ctermbg=0 ctermfg=4
highlight StatusLineNC cterm=bold ctermbg=0 ctermfg=2
set fillchars=stl:\ ,stlnc:\ 

let c_space_errors=1
let c_no_comment_fold=1
let c_no_if0_fold=1

set concealcursor=nv

""" Shortcuts
map <unique> <F1> <ESC>:make<CR>
set makeprg=make\ -j4\ -w
nmap <unique> <Leader>s vip:sort u<CR>
vmap <unique> <Leader>s :sort u<CR>
nmap <unique> <Leader>S vip:sort iu<CR>
vmap <unique> <Leader>S :sort iu<CR>
map <unique> <Leader>w :wa<CR>

" Git
nmap <unique> gs :!git status -s -b .<CR>
nmap <unique> gS :!git status -s -b<CR>
nmap <unique> gc :!git commit -v<CR>
nmap <unique> g. :!git add -p .<CR>
nmap <unique> g; :!git add -i .<CR>
nmap <unique> g? :!git diff .<CR>
nmap <unique> g/ :!git diff --cached .<CR>
nmap <unique> gv :!git pull --ff --commit<CR>
nmap <unique> g^ :!git push<CR>
nmap <unique> gP :!git checkout -p .<CR>

set shell=/bin/bash

" Paste toggle
nmap <unique> <Leader>p :set paste!<CR>

function! s:escape_sub(s)
  " See |sub-replace-special| and 'magic.
  return escape(a:s, '&~\\')
endfunction

function! s:get_work_command(prg, args)
  " See the replace_makeprg C function in vim/src/ex_docmd.c for undocumented
  " behaviour.
  " See 'grepprg/'makeprg for '$*'.
  " See |string-match| for '\$\*'.
  let expanded=substitute(a:prg, '\$\*', s:escape_sub(a:args), 'g')
  if expanded ==# a:prg
    return a:prg.' '.a:args
  else
    return expanded
  endif
endfunction

function! s:get_work_redirect(shellpipe, shellquote, error_file_path)
  " See the replace_makeprg C function in vim/src/ex_docmd.c for undocumented
  " behaviour.
  " See the append_redir C function in vim/src/ex_cmds.c for undocumented
  " behaviour.
  " TODO(strager): Support empty 'shellpipe.
  " TODO(strager): Support %% in 'shellpipe.
  " TODO(strager): Maybe crash if 'shellpipe is '%s%s'.
  let expanded_shellpipe=substitute(a:shellpipe, '%s', s:escape_sub(a:error_file_path), '')
  if expanded_shellpipe ==# a:shellpipe
    return ' '.a:shellpipe.' '.a:error_file_path
  else
    return ' '.expanded_shellpipe
  endif
endfunction

function s:StragerMakeCallback(work, channel, message)
  if a:work['done']
    return
  endif

  call s:update_quickfix_list(a:work, 'incremental')
endfunction

function s:StragerMakeCloseCallback(channel)
endfunction

function s:StragerMakeExitCallback(work, _job, _exit_status)
  if a:work['done']
    return
  endif

  call s:update_quickfix_list(a:work, 'full')

  " See the ex_make C function in vim/src/quickfix.c.
  call delete(a:work['error_file_path'])
  let a:work['done']=v:true
endfunction

function s:list_index_where(list, predicate)
  let index=0
  for x in a:list
    if a:predicate(x)
      return index
    endif
    let index=index + 1
  endfor
  return -1
endfunction

function s:parse_new_quickfix_entries_from_error_file(work, incremental_or_full)
  " TODO(strager): Support <CR><LF>.
  " TODO(strager): Ensure encoding is correct.
  " TODO(strager): Use a buffer instead.
  " TODO(strager): Verify multi-line error messages are parsed properly.
  let raw_lines=readfile(a:work['error_file_path'], 'b')
  if a:incremental_or_full ==# 'incremental'
    " Strip off the last line.
    " * If the last line in the file is incomplete (i.e. lacks a trailing <LF>),
    "   we don't want to parse it to avoid truncated messages.
    " * If the last line in the file is complete (i.e. has a trailing <LF>),
    "   readfile() returns an empty string as the last item in the list
    let lines_to_parse=raw_lines[:-2]
  elseif a:incremental_or_full ==# 'full'
    let lines_to_parse=raw_lines
  else
    " TODO(strager): Communicate a proper error.
    echomsg 'Invalid value '.string(a:incremental_or_full).'; expected "incremental" or "full"'
    return []
  endif
  let parsed_quickfix_entries=getqflist({
    \ 'efm': a:work['error_format'],
    \ 'lines': lines_to_parse,
  \ })['items']
  let current_quickfix_entries=getqflist({
    \ 'id': a:work['quickfix_list_id'],
    \ 'items': v:true,
  \ })['items']

  " TODO(strager): Return only new entries.
  return parsed_quickfix_entries
endfunction

function s:update_quickfix_list(work, incremental_or_full)
  let new_quickfix_entries=s:parse_new_quickfix_entries_from_error_file(a:work, a:incremental_or_full)
  " TODO(strager): Append instead of replacing.
  call setqflist([], 'r', {
    \ 'id': a:work['quickfix_list_id'],
    \ 'items': new_quickfix_entries,
  \ })

  " TODO(strager): Trigger QuickFixCmdPost.

  " Automatically jump to the first error if desired.
  if a:work['jump_to_first_error'] && !a:work['did_jump_to_first_error']
    " See the ex_make C function in vim/src/quickfix.c.
    let cur_quickfix_list_id=getqflist({'id': 0})['id']
    if cur_quickfix_list_id == a:work['quickfix_list_id']
      " TODO(strager): Check new_quickfix_entries instead.
      let index=s:list_index_where(getqflist(), {entry -> entry['valid']})
      if index != -1
        execute 'cc '.(index + 1)
        let a:work['did_jump_to_first_error']=v:true
      endif
    endif
  endif
endfunction

function s:StragerMake(bang, mode, args)
  " TODO(strager): Support 'makeef.
  let error_file_path=tempname()
  " NOTE(strager): Despite what the documentation for :make says, this deletion
  " is unconditional.
  call delete(error_file_path)

  if a:mode ==# 'grep'
    let prg=get(b:, 'grepprg', &grepprg)
  elseif a:mode ==# 'make'
    let prg=get(b:, 'makeprg', &makeprg)
  else
    echomsg 'Invalid mode '.string(a:mode)
    return
  endif
  let command=s:get_work_command(prg, a:args)
  let redirect=s:get_work_redirect(&shellpipe, &shellquote, error_file_path)
  " TODO(strager): Support 'shellquote.

  " TODO(strager): Trigger QuickFixCmdPre.
  " TODO(strager): Ensure encoding is correct.
  " TODO(strager): Support 'autowrite and 'autowriteall.

  let work={
    \ 'did_jump_to_first_error': v:false,
    \ 'done': v:false,
    \ 'error_file_path': error_file_path,
    \ 'jump_to_first_error': !a:bang,
  \ }

  " TODO(strager): Support Windows.
  " FIXME(strager): I think this is wrong. Vim is confusing.
  let exec_command=[&shell,&shellcmdflag,command.redirect]
  " HACK(strager): For some reason, term_start() moves the cursor to the
  " beginning of the buffer. Save and restore the window state to work around
  " this.
  let window_view=winsaveview()
  let terminal_buffer_number=term_start(exec_command, {
    \ 'callback': function('s:StragerMakeCallback', [work]),
    \ 'close_cb': function('s:StragerMakeCloseCallback'),
    \ 'err_msg': v:false,
    \ 'exit_cb': function('s:StragerMakeExitCallback', [work]),
    \ 'hidden': v:true,
    \ 'out_msg': v:false,
    \ 'stoponexit': 'term',
    \ 'term_name': command,
  \ })
  call winrestview(window_view)
  if terminal_buffer_number == 0
    " TODO(strager): Handle errors.
    echomsg 'Error in term_start()'
  endif
  let work['terminal_buffer_number']=terminal_buffer_number

  " TODO(strager): Trigger ShellCmdPost.

  if a:mode ==# 'grep'
    let error_format=get(b:, 'grepformat', &grepformat)
  elseif a:mode ==# 'make'
    let error_format=get(b:, 'errorformat', &errorformat)
  else
    echomsg 'Invalid mode '.string(a:mode)
    return
  endif
  let work['error_format']=error_format

  " See the ex_make C function in vim/src/quickfix.c for ':'.
  let quickfix_title=':'.command

  " TODO(strager): Support :grepadd, etc.
  " TODO(strager): Support :lmake, etc.
  " See the ex_make C function in vim/src/quickfix.c for ' ' and 'nr': 0.
  let error=setqflist([], ' ', {
    \ 'efm': error_format,
    \ 'nr': 0,
    \ 'title': quickfix_title,
  \ })
  " TODO(strager): Check for errors.
  let quickfix_list_info=getqflist({'id': 0, 'nr': 0})
  let work['quickfix_list_id']=quickfix_list_info['id']
endfunction

" BANG = -bang
" EXTRA = ???
" NOTRLCOM = (default; -bar overrides)
" TRLBAR = (default; -bar overrides)
" XFILE = ???
" ADDR_LINES = (unused, I think)
command -bang -complete=file -nargs=* StragerGrep call s:StragerMake(<bang>0, 'grep', <q-args>)
command -bang -complete=file -nargs=* StragerMake call s:StragerMake(<bang>0, 'make', <q-args>)

set grepformat=%f:%l:%c:%m grepprg=ag\ --nocolor\ --nogroup\ --column

" Must be last.  Forgot why.
set exrc secure
